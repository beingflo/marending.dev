---
title: 'Understanding passkeys'
subtitle: 'And implementing a proof of concept'
date: '10 Jan 2026'
link: '/notes/passkeys/'
layout: 'src/layouts/NoteLayout.astro'
draft: true
---

I've been wanting to start using passkeys for a while now. I even bought two
[Yubikeys](https://www.yubico.com/products/) 5 (!) years ago and have been
carrying one of them on my keychain ever since with the intention of putting
them in operation any day now. Alas, it hasn't happened yet. I blame it partly
on the terrible marketing surrounding them and partly on my laziness. So now,
I finally want to dive deep, properly understand and start using them.

## What are passkeys
First, we need to properly understand what we're even talking about. Passkeys are
commonly defined as 
[WebAuthn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) 
credentials. The Web Authentication API is a W3C standard to enable authentication
with public key cryptography. It fits into the broader 
[FIDO2](https://fidoalliance.org/passkeys/) standard, along with the Client to 
Authenticator Protocol (CTAP). All this is to say is that if you want to use 
passkeys in a web application, the application is asking the browser to authenticate
with passkeys via WebAuthn and the browser is then talking to authenticators (like 
a Yubikey or a password manager) via CTAP.

So, passkeys are simply a key pair stored in an authenticator.

## Advantages of passkeys
The security industry has learned from the way traditional passwords have
been exploited have thus built a bunch of improvements into the standards behind
passkeys:

- They are generated by the authenticator, not the user. This makes it impossible to
accidentally generate weak passkeys, like it is commonly done with passwords. As a result,
passkeys are also automatically unique as the user has no chance to reuse one.
- The key to prove your identity and the key to check your proof are not the same. 
This means that the server does not need to store your secret in a secure way, instead,
it can hold onto your public key carelessly. If a site is breached, nothing of value about
your ability to authenticate can be stolen. Passwords on the other hand are a shared
secret between user and server, so the server must take great care to handle it responsibly.
- They offer protection against phishing. Passkeys are bound to an origin, that means
an attacker cloning a website can not coax your authenticator into signing a challenge.
Users with passwords on the other hand readily type them into a fake site that looks real.
- They are easy to use. While most of us use password managers, the process of auto filling
username and password fields is error prone, as it relies on parsing the web page for fields
with appropriate attributes. Many sites do this wrong, leading to having to copy and paste
passwords. Passkeys on the other hand build on proper programmatic APIs that can be easily
implemented to specification by website, browser and authenticator. This should make the
process seamless and robust.

## Authenticators 

As a recap, the authenticator is the component that generates public-private key pairs for
registration and then signs challenges using the private key for authentication. It can
come in the form of software (like a password manager), or as dedicated hardware 
(like a security key).

They are commonly separated into platform and cross-platform (or roaming).
Platform authenticators come built into your device, like Apple Face ID or Windows Hello.
Cross-platform authenticators are portable. For instance security keys or password managers
are cross-platform as they can be used from multiple devices. Smartphones can simultaneously
be platform authenticators when signing in _on device_ or roaming authenticators when used
to sign in _on another device_.

The FIDO2 standard requires authenticators to at least support testing for _user presence_. 
A security key for instance will require the user to touch a capacitive button before a
challenge is signed. The Apple Face ID authenticator will additionally also support
_user verification_ via biometrics or PIN.

Notice that how key pairs are stored is not part of the specification. Some authenticators like
security keys will generate a key pair and never hand out a private key. This means the key
is tied to the physical possession of the device. Password managers on the other hand will offer
to sync passkeys between your devices. This added comfort comes at the cost of having to trust
your password manager to keep your keys safe in transit.

## Registration and authentication flows
![registration flow](./register.svg)
![authentication flow](./authenticate.svg)


## Misconceptions
- loosing security key -> lose access
- 2fa
- biometrics

## Implementation