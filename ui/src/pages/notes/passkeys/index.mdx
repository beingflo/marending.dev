---
title: 'Understanding passkeys'
subtitle: 'And implementing a proof of concept'
date: '10 Jan 2026'
link: '/notes/passkeys/'
layout: 'src/layouts/NoteLayout.astro'
draft: true
---

I've been wanting to start using passkeys for a while now. I even bought two
[Yubikeys](https://www.yubico.com/products/) 5 (!) years ago and have been
carrying one of them on my keychain ever since with the intention of putting
them in operation any day now. Alas, it hasn't happened yet. I blame it partly
on the terrible marketing surrounding passkeys and partly on my laziness. So now,
I finally want to dive deep, properly understand and start using them.

## What are passkeys
First, we need to properly understand what we're even talking about. Passkeys are
commonly defined as 
[WebAuthn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) 
credentials. The Web Authentication API is a W3C standard to enable authentication
with public key cryptography. It fits into the broader 
[FIDO2](https://fidoalliance.org/passkeys/) standard, along with the Client to 
Authenticator Protocol (CTAP). All this is to say is that if you want to use 
passkeys in a web application, the application is asking the browser to authenticate
with passkeys via WebAuthn and the browser is then talking to authenticators (like 
a Yubikey or a password manager) via CTAP.

So, passkeys are simply a key pair stored in an authenticator.

## Advantages of passkeys
The security industry has learned from the way traditional passwords have
been exploited have thus built a bunch of improvements into the standards behind
passkeys:

- They are generated by the authenticator, not the user. This makes it impossible to
accidentally generate weak passkeys, like it is commonly done with passwords. As a result,
passkeys are also automatically unique as the user has no chance to reuse one.
- The key to prove your identity and the key to check your proof are not the same. 
This means that the server does not need to store your secret in a secure way, instead,
it can hold onto your public key carelessly. If a site is breached, nothing of value about
your ability to authenticate can be stolen. Passwords on the other hand are a shared
secret between user and server, so the server must take great care to handle it responsibly.
- They offer protection against phishing. Passkeys are bound to an origin, that means
an attacker cloning a website can not coax your authenticator into signing a challenge.
Users with passwords on the other hand readily type them into a fake site that looks real.
- They are easy to use. While most of us use password managers, the process of auto filling
username and password fields is error prone, as it relies on parsing the web page for fields
with appropriate attributes. Many sites do this wrong, leading to having to copy and paste
passwords. Passkeys on the other hand build on proper programmatic APIs that can be easily
implemented to specification by website, browser and authenticator. This should make the
process seamless and robust.

## Authenticators 
As a recap, the authenticator is the component that generates public-private key pairs for
registration and then signs challenges using the private key for authentication. It can
come in the form of software (like a password manager), or as dedicated hardware 
(like a security key).

They are commonly separated into platform and cross-platform (or roaming).
Platform authenticators come built into your device, like Apple Face ID or Windows Hello.
Cross-platform authenticators are portable. For instance security keys or password managers
are cross-platform as they can be used from multiple devices. Smartphones can simultaneously
be platform authenticators when signing in _on device_ or roaming authenticators when used
to sign in _on another device_.

The FIDO2 standard requires authenticators to at least support testing for _user presence_. 
A security key for instance will require the user to touch a capacitive button before a
challenge is signed. The Apple Face ID authenticator will additionally also support
_user verification_ via biometrics or PIN.

Notice that how key pairs are stored is not part of the specification. Some authenticators like
security keys will generate a key pair and never hand out a private key. This means the key
is tied to the physical possession of the device. Password managers on the other hand will offer
to sync passkeys between your devices. This added comfort comes at the cost of having to trust
your password manager to keep your keys safe in transit.

## Registration and authentication flows
Now that we have a good understanding of what authenticators do, let's check how they 
interact with clients. The diagrams are simplified of course but should visualize how
information flows between clients, authenticators and servers.
First the registration flow to establish new credentials:

![registration flow](./register.svg)

Following this, existing credentials are used to authenticate:

![authentication flow](./authenticate.svg)


## Misconceptions
With the basics out of the way, let's look at some common misconceptions to clarify our
understanding.

### If you lose the device with the passkey, you're locked out
When I first learned about passkeys and wanted to try them, they were often used synonymously
with security keys. So my biggest misunderstanding that prevented me from adopting passkeys was
the belief that if I lose my Yubikey, I'm going to be locked out of my accounts. The common advice
at that time was to get a _second_ Yubikey and register a passkey to each device for every
account. Then, deposit one security key in a safe spot so that if you lose the one that you have
with you, there is a fallback.

This misses one crucial piece of information: Passkeys simply replace passwords, they don't
claim much more than that. So what do you do if you misplace your password? You enter a "Forgot
my password" flow on the auth page of a service. Turns out you can do exactly the same if you
lost your passkey. Most services will allow you to register a new passkey this way if you can
prove your identity, usually by accessing your email account. Further, services typically don't
disable other authentication methods just because you registered a passkey. In the case of
Github for instance, you have the option to sign in via passkey or via username / password + two
factor authentication.

Naturally this has security implications. Your shiny new passkey is only as secure as your
email account. For this reason some services will allow you to disable other authentication
modes and fallback mechanisms. You better know what you're doing then, though.

Finally, most people are going to be saving their passkeys in synchronizing authenticators, like
platform keychains or password managers. For these, losing a device doesn't matter much anyway as
long as you have a way to get back into the authenticator.

### Passkeys replace 2FA
This is a quite contentious take that illustrates how poor the general understanding of security
is around the internet. You'll read many misguided arguments that don't hold up to scrutiny.
After some research it seems a reasonable take is as follows: If the authenticator employs
_user verification_ during authentication, passkeys do indeed provide similar security guarantees
as passwords with a second factor. Access to the authenticator is something _you have_ and the
biometrics or password you use to unlock your authenticator are something _you are or know_.
Thus, you have 2 factors. Now, if your authenticator is _not_ verifying you during authentication,
but only tests for your presence (as the standard requires), you only have one factor, the physical
possession of the authenticator. An example of such an authenticator is a security key that hands
out signatures at the touch of a button.

Github seems to have come to the same conclusion as they force the use of 2FA when using passwords,
but allow using passkeys with no other factor. Also note that passkeys can be used as the second
factor to strengthen passwords.

## How do I use passkeys now?

## Implementation