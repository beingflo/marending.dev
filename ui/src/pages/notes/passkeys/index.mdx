---
title: 'Understanding passkeys'
subtitle: 'And implementing a proof of concept'
date: '16 Jan 2026'
link: '/notes/passkeys/'
layout: 'src/layouts/NoteLayout.astro'
draft: true
---

I've been wanting to start using passkeys for a while now. I even bought two
[Yubikeys](https://www.yubico.com/products/) 5 (!) years ago and have been
carrying one of them on my keychain ever since with the intention of putting
them in operation any day now. Alas, it hasn't happened yet. I blame it partly
on the terrible marketing surrounding passkeys and partly on my laziness. So now,
I finally want to dive deep, properly understand and start using them.

## What are passkeys
First, we need to properly understand what we're even talking about. Passkeys are
commonly defined as 
[WebAuthn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) 
credentials. The Web Authentication API is a W3C standard to enable authentication
with public key cryptography. It fits into the broader 
[FIDO2](https://fidoalliance.org/passkeys/) standard, along with the Client to 
Authenticator Protocol (CTAP). All this is to say is that if you want to use 
passkeys in a web application, the application is asking the browser to authenticate
with passkeys via WebAuthn and the browser is then talking to authenticators (like 
a Yubikey or a password manager) via CTAP.

So, passkeys are simply a key pair stored in an authenticator.

## Advantages of passkeys
The security industry has learned from the way traditional passwords have
been exploited have thus built a bunch of improvements into the standards behind
passkeys:

- They are generated by the authenticator, not the user. This makes it impossible to
accidentally generate weak passkeys, like it is commonly done with passwords. As a result,
passkeys are also automatically unique as the user has no chance to reuse one.
- The key to prove your identity and the key to check your proof are not the same. 
This means that the server does not need to store your secret in a secure way, instead,
it can hold onto your public key carelessly. If a site is breached, nothing of value about
your ability to authenticate can be stolen. Passwords on the other hand are a shared
secret between user and server, so the server must take great care to handle it responsibly.
- They offer protection against phishing. Passkeys are bound to an origin, that means
an attacker cloning a website can not coax your authenticator into signing a challenge.
Users with passwords on the other hand readily type them into a fake site that looks real.
- They are easy to use. While most of us use password managers, the process of auto filling
username and password fields is error prone, as it relies on parsing the web page for fields
with appropriate attributes. Many sites do this wrong, leading to having to copy and paste
passwords. Passkeys on the other hand build on proper programmatic APIs that can be easily
implemented to specification by website, browser and authenticator. This should make the
process seamless and robust.

## Authenticators 
As a recap, the authenticator is the component that generates public-private key pairs for
registration and then signs challenges using the private key for authentication. It can
come in the form of software (like a password manager), or as dedicated hardware 
(like a security key).

They are commonly separated into platform and cross-platform (or roaming).
Platform authenticators come built into your device, like Apple Face ID or Windows Hello.
Cross-platform authenticators are portable. For instance security keys or password managers
are cross-platform as they can be used from multiple devices. Smartphones can simultaneously
be platform authenticators when signing in _on device_ or roaming authenticators when used
to sign in _on another device_.

The FIDO2 standard requires authenticators to at least support testing for _user presence_. 
A security key for instance will require the user to touch a capacitive button before a
challenge is signed. The Apple Face ID authenticator will additionally also support
_user verification_ via biometrics or PIN.

Notice that how key pairs are stored is not part of the specification. Some authenticators like
security keys will generate a key pair and never hand out a private key. This means the key
is tied to the physical possession of the device. Password managers on the other hand will offer
to sync passkeys between your devices. This added comfort comes at the cost of having to trust
your password manager to keep your keys safe in transit.

## Registration and authentication flows
Now that we have a good understanding of what authenticators do, let's check how they 
interact with clients. The diagrams are simplified of course but should visualize how
information flows between clients, authenticators and servers.
First the registration flow to establish new credentials:

![registration flow](./register.svg)

Following this, existing credentials are used to authenticate:

![authentication flow](./authenticate.svg)


## Misconceptions
With the basics out of the way, let's look at some common misconceptions to clarify our
understanding.

### If you lose the device with the passkey, you're locked out
When I first learned about passkeys and wanted to try them, they were often used synonymously
with security keys. So my biggest misunderstanding that prevented me from adopting passkeys was
the belief that if I lose my Yubikey, I'm going to be locked out of my accounts. The common advice
at that time was to get a _second_ Yubikey and register a passkey to each device for every
account. Then, deposit one security key in a safe spot so that if you lose the one that you have
with you, there is a fallback.

This misses one crucial piece of information: Passkeys simply replace passwords, they don't
claim much more than that. So what do you do if you misplace your password? You enter a "Forgot
my password" flow on the auth page of a service. Turns out you can do exactly the same if you
lost your passkey. Most services will allow you to register a new passkey this way if you can
prove your identity, usually by accessing your email account. Further, services typically don't
disable other authentication methods just because you registered a passkey. In the case of
Github for instance, you have the option to sign in via passkey or via username / password + two
factor authentication.

Naturally this has security implications. Your shiny new passkey is only as secure as your
email account. For this reason some services will allow you to disable other authentication
modes and fallback mechanisms. You better know what you're doing then, though.

Finally, most people are going to be saving their passkeys in synchronizing authenticators, like
platform keychains or password managers. For these, losing a device doesn't matter much anyway as
long as you have a way to get back into the authenticator.

### Passkeys replace 2FA
This is a quite contentious take that illustrates how poor the general understanding of security
is around the internet. You'll read many misguided arguments that don't hold up to scrutiny.
After some research it seems a reasonable take is as follows: If the authenticator employs
_user verification_ during authentication, passkeys do indeed provide similar security guarantees
as passwords with a second factor. Access to the authenticator is something _you have_ and the
biometrics or password you use to unlock your authenticator are something _you are or know_.
Thus, you have 2 factors. Now, if your authenticator is _not_ verifying you during authentication,
but only tests for your presence (as the standard requires), you only have one factor, the physical
possession of the authenticator. An example of such an authenticator is a security key that hands
out signatures at the touch of a button.

Now, this line of reasoning feels suspect to me. By this logic my use of passwords stored in a
password manager would also qualify as two factors: Access to authenticator and biometrics to unlock.
I suppose the big difference is that for passwords, a service can not assume that they are handled
correctly - strong, unique, stored in a password manager. Whereas passkeys are guaranteed to have these
properties. Another iffy aspect of the argument is what happens when your password manager is
breached. In that scenario you're immediately compromised. A password in a password manager and an 
OTP code provided by an authenticator app on your phone would save you from this. 

So counting factors is not all that matters here, separate password store and OTP generator 
give you two _trust anchors_, versus just the one with passkeys. Instead, we have to consider that
2FA methods were conceived to reduce attack surface by making passwords no longer sufficient to 
authenticate alone. This way, attackers who gain access to passwords via phishing, database breaches etc.
can't log in without also tricking you into providing the second factor. From this perspective it's clear
why services like Github consider passkeys sufficiently strong to replace password + 2FA, they
solve this attack surface by binding keys to origins and eliminating shared secrets.

Also note that passkeys can be used as the second factor to strengthen passwords.

## How do I use passkeys now?
Now with a decent understanding of passkeys established, what do I do with this information?
First, let me elaborate where I'm coming from. I was always very lazy when it comes to 2FA, to
this date I have 2FA enabled only on the services that force me to use it. As someone that
considers himself a well informed power user, this is a point of shame for me (hence I'm writing
this note finally). However, after the above revelation that properly managed passwords 
are actually not _that_ much worse than passkeys, it's easy to feel validated and 
continue to do business as usual.

Instead, now that the uncertainty of how this technology works exactly is gone, I can focus on
the ease of use of passkeys. Especially _discoverable credentials_ (passkeys that contain
metadata about the user) are just magical: You navigate to a login page, get a popup from your
authenticator, put your finger on the fingerprint sensor, click on "Sign in" and that's it. 
No entering usernames, no scrambling to get your phone for the OTP code. That ease of use
coupled with the improved security actually make it a no-brainer to use passkeys.

But which authenticator to use? For me, built in platform authenticators are not an option due
to vender lock-in. Undoubtedly this is part of the reason companies like Apple are pushing
passkeys and were very fast to support them. There _is_ a draft specification now that will
allow exchanging credentials between authenticators, but it's still best to avoid it all together.

So password managers and security keys are still in the race. 
Password managers boast the following advantages:

- Convenience & usability. They are easy to access via biometrics or password and are available on all 
devices.
- Easy recovery. They synchronize passkeys across devices and into the cloud, ensuring they aren't
lost when a device breaks.

Security keys on the other hand have one main strength: Security. Passkeys on a Yubikey are 
hardware-bound. No breach of any online service is going to compromise credentials.

Ultimately I think I don't fit the profile of a high-security user that would need hardware
based security. The convenience of password managers wins out for my use cases.

### Some observations

General:
When wanting to use security key: First dismiss password manager prompt, then click small "other
options" when Apple inserts itself, then select security key.

Does it make sense to store secondary passkeys on yubikey incase I lose access to 1password?
-> Yes probably

Does it make sense to have password (1password) + 2FA app on phone?
-> Probably not, if I lose access to 1password I also lose access to the password.

Do I increase my surface by adding more authentication mechanisms without taking others away?
-> Maybe?

Github:
Either password + 2FA or passkey
When registering secondary passkeys on security keys I have to set up pin. It looks like
Github requires user verification, so just touching the capacitive button on the Yubikey is not
sufficient like with the other services below.
-> Usability when logging in kind of weird. When I already entered the PIN before, I can just
touch the button on the login page and I'm in. However, when I've newly plugged the key in, touching
the button doesn't do anything, instead I have to dismiss the password manager prompt, select
security key and then I'm prompted for the PIN and can log in.
And now that I've set PINs on my keys for Github, I have to enter them for other accounts as well.

Porkbun:
Once passkey is registered, password doesn't work anymore but it's not mentioned.
Also has the option to force user verification.

Fastmail:
Here I don't have the option to use my Yubikey, maybe they require attestation that the security 
key can't fulfill?
-> Actually I need to select "On another device", then it will allow the selection of security
key.

SSH:


## Implementation