---
title: 'Reflective: A simple self-hosted image gallery'
subtitle: 'A project report'
date: '30 Dec 2025'
link: '/notes/reflective/'
layout: 'src/layouts/NoteLayout.astro'
draft: false 
---

import { Details, Hint } from 'src/components';

Let me take you back to around 6 years ago. I was starting to 
[de-Google](https://en.wikipedia.org/wiki/DeGoogle) my life, replacing Google Drive 
and Google Photos with [pCloud](https://www.pcloud.com/). Now, while pCloud is fine as a
cloud storage provider, it really didn't nail the photo aspect of it. At that time,
viewing images was painfully slow, as in, taking 10 seconds for any thumbnail to load.
It felt as if they were regenerating thumbnails on every view.

This made me wonder if hosting and efficiently serving images was really that hard, 
or if pCloud simply didn't care about the user experience. Google was pulling it off, 
but maybe that was a result of hundreds of engineers and specialized compression schemes.

So I set out on my first ever attempt at a side project (apart from some smaller CLI tools
and such) with _[foti](https://github.com/beingflo/foti/tree/master)_. This is code I wrote
with around 1 month of on-the-job frontend experience. View it at your own risk. I was using
a Python server that eagerly downsampled images for thumbnails and served them up via a 
WebSocket connection (for whatever reason). The whole thing was running on a Raspberry Pi 4
in a box in my cupboard.

While the result wasn't pretty, it served to validate my suspicion: Serving images at anything
faster than a glacial pace _wasn't that hard_. With a proof-of-concept in the bag and my appetite
for side projects awakened, I decided to first hone my web dev skills on an "easier" target: 
note taking. In my mind, I would quickly build a note-taking application to satisfy a personal
need, learning a ton in the process, and then swiftly return to my actual goal - the image gallery.

If you've read about [fieldnotes](/notes/fieldnotes), you'll know that this was more than a short
intermezzo. I lost myself there for a couple of years, then a bunch of other [projects](/projects) 
snuck in and here we are, quite a while later. Once I finally got back to it, I started sketching
out the feature set and architecture, only to be distracted again by another project. In the second
round of getting back to it, I drastically cut down the scope and finally pushed it over the line.
This is the version I'm writing about now. As always, there are a bunch of learnings here. Reflecting
on those is the main reason I write these project reports.

<Hint>
	Other notes in my project report series:
	- [fieldnotes](/notes/fieldnotes/)
	- [rest.quest](/notes/rest-quest/)
	- [go](/notes/go-rest-quest/)
</Hint>

## Features

[Reflective](https://github.com/beingflo/reflective) is currently a simple gallery for
distraction-free viewing of my images. The main view one is greeted with when opening the web app
is a grid of all the images ingested into the system:

![Screenshot of reflective](./_view.png)

No buttons or labels around to distract from the images. When scrolling, the application seamlessly loads
in more images. All images are cropped to a 4:3 landscape aspect ratio.

There is no categorization into albums or folders, it's a simple feed of images in reverse chronological order.

Images can have an arbitrary number of tags associated with them. When looking for specific images, one can
open the search bar via shortcut (`cmd+k`) and search for any tag. In the following screenshot, the images are
filtered down to ones with a tag titled `japan`. There are 1860 images matching that query.

![Screenshot of reflective](./_search.png)

To tag images, one can open the tag view (`cmd+e`) and select individual images, or all the images between two
selections by holding down `Shift`. The tag bar now shows tags that all selected images have in common, ones that
only some images have (in lighter gray), as well as an input field to add new tags to all selected images.

![Screenshot of reflective](./_tags.png)

Back in normal view mode, one can open an image in fullscreen view by clicking on it. A lightbox now fills 
the screen, there are shortcuts to switch to the previous and next image as well as loading in a full-resolution
version of the image to zoom in for details.

![Screenshot of reflective](./_lightbox.png)

Further, hitting `cmd+i` displays some selected metadata of the image file below the image.

![Screenshot of reflective](./_metadata.png)

To ingest images into reflective, I copy files into a folder on my server and create a marker file in a 
certain location. The server will now recognize that there are new files and will start downsampling the
new images for thumbnails. Once that process is complete, the new images will appear in the view.

## Architecture

As with [rest.quest](/notes/rest-quest), I first brainstormed on paper what the application should do
and how it should work. For reflective this turned out to be quite a bit of rambling, but I do have
to say that I enjoy this process. In hindsight, I once again over-engineered a lot - it's always easy
to think up a mechanism or feature, but only when it's time to implement it does my pragmatism set in.

In the scans you can look at below, you'll find much of my thought process detailed.

<Details title="Full concept">
	See if you can find the angry cow in prison.
	<div class="md:w-3/4 w-full mx-auto">
		![Screenshot of UX concept](./_reflective-page1.jpeg)
		![Screenshot of UX concept](./_reflective-page2.jpeg)
		![Screenshot of UX concept](./_reflective-page3.jpeg)
		![Screenshot of UX concept](./_reflective-page4.jpeg)
		![Screenshot of UX concept](./_reflective-page5.jpeg)
		![Screenshot of UX concept](./_reflective-page6.jpeg)
		![Screenshot of UX concept](./_reflective-page7.jpeg)
		![Screenshot of UX concept](./_reflective-page8.jpeg)
		![Screenshot of UX concept](./_reflective-page9.jpeg)
		![Screenshot of UX concept](./_reflective-page10.jpeg)
		![Screenshot of UX concept](./_reflective-page11.jpeg)
		![Screenshot of UX concept](./_reflective-page12.jpeg)
		![Screenshot of UX concept](./_reflective-page13.jpeg)
		![Screenshot of UX concept](./_reflective-page14.jpeg)
		![Screenshot of UX concept](./_reflective-page15.jpeg)
		![Screenshot of UX concept](./_reflective-page16.jpeg)
		![Screenshot of UX concept](./_reflective-page17.jpeg)
		![Screenshot of UX concept](./_reflective-page18.jpeg)
		![Screenshot of UX concept](./_reflective-page19.jpeg)
		![Screenshot of UX concept](./_reflective-page20.jpeg)
		![Screenshot of UX concept](./_reflective-page21.jpeg)
		![Screenshot of UX concept](./_reflective-page22.jpeg)
		![Screenshot of UX concept](./_reflective-page23.jpeg)
		![Screenshot of UX concept](./_reflective-page24.jpeg)
		![Screenshot of UX concept](./_reflective-page25.jpeg)
		![Screenshot of UX concept](./_reflective-page26.jpeg)
		![Screenshot of UX concept](./_reflective-page27.jpeg)
		![Screenshot of UX concept](./_reflective-page28.jpeg)
		![Screenshot of UX concept](./_reflective-page29.jpeg)
		![Screenshot of UX concept](./_reflective-page30.jpeg)
		![Screenshot of UX concept](./_reflective-page31.jpeg)
		![Screenshot of UX concept](./_reflective-page32.jpeg)
		![Screenshot of UX concept](./_reflective-page33.jpeg)
		![Screenshot of UX concept](./_reflective-page34.jpeg)
	</div>
</Details>

At first, it was clear to me that I should store image data in S3. After all, storing images on my server
was not scalable. It's architecturally not a good idea to collocate so much data with the application server.
But storing the data and the metadata about the images in separate places introduces the problem of keeping
the two in sync. You can find a lot of musing about this issue in my notes.

But once again, I expertly avoided the thought that this is ultimately only going to be used by me and I might
as well just ignore this whole problem. So after already having implemented the whole ordeal with upload
functionality, presigned S3 URLs, etc., I decided to unceremoniously rip it out and instead just store the 
images on the server, have the server asynchronously process them for thumbnails and such, and then just 
serve the images directly.

So as it stands right now, the architecture has been simplified to the point that it's not worth discussing 
further.

## Learnings

Reflective is a continuation of my eternal battle against over-engineering. By now, I have the concept of
MVP scope down, I always try to simplify down to a barely usable application and then see where
I go from there. The problem this time around was the scope included functionality for an imaginary 
user-base. I hadn't yet internalized the idea of 
[home-cooked software](https://www.robinsloan.com/notes/home-cooked-app/) yet.

Halfway through the concept I even wrote the following in my notes: 

> Reminder to build for yourself and not over-engineer for an imaginary user-base!
>
> - Me (to myself)

And yet I just carried on designing a system that would scale to a large user-base instead of focusing
on what _I_ need. Having built significant functionality that I removed again to simplify hopefully
trained me to recognize such situations earlier next time.